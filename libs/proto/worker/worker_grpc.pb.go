// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v5.29.3
// source: proto/worker/worker.proto

package worker

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	WorkerManagerService_RegisterWorker_FullMethodName       = "/worker.WorkerManagerService/RegisterWorker"
	WorkerManagerService_GetWorker_FullMethodName            = "/worker.WorkerManagerService/GetWorker"
	WorkerManagerService_UpdateWorkerStatus_FullMethodName   = "/worker.WorkerManagerService/UpdateWorkerStatus"
	WorkerManagerService_ListWorkers_FullMethodName          = "/worker.WorkerManagerService/ListWorkers"
	WorkerManagerService_FindAvailableWorkers_FullMethodName = "/worker.WorkerManagerService/FindAvailableWorkers"
)

// WorkerManagerServiceClient is the client API for WorkerManagerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WorkerManagerServiceClient interface {
	// RegisterWorker registers a new worker in the system
	RegisterWorker(ctx context.Context, in *RegisterWorkerRequest, opts ...grpc.CallOption) (*WorkerResponse, error)
	// GetWorker retrieves a worker by its ID
	GetWorker(ctx context.Context, in *GetWorkerRequest, opts ...grpc.CallOption) (*WorkerResponse, error)
	// UpdateWorkerStatus updates the status of a worker
	UpdateWorkerStatus(ctx context.Context, in *UpdateWorkerStatusRequest, opts ...grpc.CallOption) (*UpdateWorkerStatusResponse, error)
	// ListWorkers retrieves all workers with optional filtering
	ListWorkers(ctx context.Context, in *ListWorkersRequest, opts ...grpc.CallOption) (*ListWorkersResponse, error)
	// FindAvailableWorkers finds workers that can handle a specific task
	FindAvailableWorkers(ctx context.Context, in *FindAvailableWorkersRequest, opts ...grpc.CallOption) (*ListWorkersResponse, error)
}

type workerManagerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkerManagerServiceClient(cc grpc.ClientConnInterface) WorkerManagerServiceClient {
	return &workerManagerServiceClient{cc}
}

func (c *workerManagerServiceClient) RegisterWorker(ctx context.Context, in *RegisterWorkerRequest, opts ...grpc.CallOption) (*WorkerResponse, error) {
	out := new(WorkerResponse)
	err := c.cc.Invoke(ctx, WorkerManagerService_RegisterWorker_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagerServiceClient) GetWorker(ctx context.Context, in *GetWorkerRequest, opts ...grpc.CallOption) (*WorkerResponse, error) {
	out := new(WorkerResponse)
	err := c.cc.Invoke(ctx, WorkerManagerService_GetWorker_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagerServiceClient) UpdateWorkerStatus(ctx context.Context, in *UpdateWorkerStatusRequest, opts ...grpc.CallOption) (*UpdateWorkerStatusResponse, error) {
	out := new(UpdateWorkerStatusResponse)
	err := c.cc.Invoke(ctx, WorkerManagerService_UpdateWorkerStatus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagerServiceClient) ListWorkers(ctx context.Context, in *ListWorkersRequest, opts ...grpc.CallOption) (*ListWorkersResponse, error) {
	out := new(ListWorkersResponse)
	err := c.cc.Invoke(ctx, WorkerManagerService_ListWorkers_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagerServiceClient) FindAvailableWorkers(ctx context.Context, in *FindAvailableWorkersRequest, opts ...grpc.CallOption) (*ListWorkersResponse, error) {
	out := new(ListWorkersResponse)
	err := c.cc.Invoke(ctx, WorkerManagerService_FindAvailableWorkers_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkerManagerServiceServer is the server API for WorkerManagerService service.
// All implementations must embed UnimplementedWorkerManagerServiceServer
// for forward compatibility
type WorkerManagerServiceServer interface {
	// RegisterWorker registers a new worker in the system
	RegisterWorker(context.Context, *RegisterWorkerRequest) (*WorkerResponse, error)
	// GetWorker retrieves a worker by its ID
	GetWorker(context.Context, *GetWorkerRequest) (*WorkerResponse, error)
	// UpdateWorkerStatus updates the status of a worker
	UpdateWorkerStatus(context.Context, *UpdateWorkerStatusRequest) (*UpdateWorkerStatusResponse, error)
	// ListWorkers retrieves all workers with optional filtering
	ListWorkers(context.Context, *ListWorkersRequest) (*ListWorkersResponse, error)
	// FindAvailableWorkers finds workers that can handle a specific task
	FindAvailableWorkers(context.Context, *FindAvailableWorkersRequest) (*ListWorkersResponse, error)
	mustEmbedUnimplementedWorkerManagerServiceServer()
}

// UnimplementedWorkerManagerServiceServer must be embedded to have forward compatible implementations.
type UnimplementedWorkerManagerServiceServer struct {
}

func (UnimplementedWorkerManagerServiceServer) RegisterWorker(context.Context, *RegisterWorkerRequest) (*WorkerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterWorker not implemented")
}
func (UnimplementedWorkerManagerServiceServer) GetWorker(context.Context, *GetWorkerRequest) (*WorkerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorker not implemented")
}
func (UnimplementedWorkerManagerServiceServer) UpdateWorkerStatus(context.Context, *UpdateWorkerStatusRequest) (*UpdateWorkerStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWorkerStatus not implemented")
}
func (UnimplementedWorkerManagerServiceServer) ListWorkers(context.Context, *ListWorkersRequest) (*ListWorkersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWorkers not implemented")
}
func (UnimplementedWorkerManagerServiceServer) FindAvailableWorkers(context.Context, *FindAvailableWorkersRequest) (*ListWorkersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindAvailableWorkers not implemented")
}
func (UnimplementedWorkerManagerServiceServer) mustEmbedUnimplementedWorkerManagerServiceServer() {}

// UnsafeWorkerManagerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorkerManagerServiceServer will
// result in compilation errors.
type UnsafeWorkerManagerServiceServer interface {
	mustEmbedUnimplementedWorkerManagerServiceServer()
}

func RegisterWorkerManagerServiceServer(s grpc.ServiceRegistrar, srv WorkerManagerServiceServer) {
	s.RegisterService(&WorkerManagerService_ServiceDesc, srv)
}

func _WorkerManagerService_RegisterWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterWorkerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagerServiceServer).RegisterWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkerManagerService_RegisterWorker_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagerServiceServer).RegisterWorker(ctx, req.(*RegisterWorkerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagerService_GetWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagerServiceServer).GetWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkerManagerService_GetWorker_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagerServiceServer).GetWorker(ctx, req.(*GetWorkerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagerService_UpdateWorkerStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateWorkerStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagerServiceServer).UpdateWorkerStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkerManagerService_UpdateWorkerStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagerServiceServer).UpdateWorkerStatus(ctx, req.(*UpdateWorkerStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagerService_ListWorkers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWorkersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagerServiceServer).ListWorkers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkerManagerService_ListWorkers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagerServiceServer).ListWorkers(ctx, req.(*ListWorkersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagerService_FindAvailableWorkers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindAvailableWorkersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagerServiceServer).FindAvailableWorkers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkerManagerService_FindAvailableWorkers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagerServiceServer).FindAvailableWorkers(ctx, req.(*FindAvailableWorkersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// WorkerManagerService_ServiceDesc is the grpc.ServiceDesc for WorkerManagerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WorkerManagerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "worker.WorkerManagerService",
	HandlerType: (*WorkerManagerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterWorker",
			Handler:    _WorkerManagerService_RegisterWorker_Handler,
		},
		{
			MethodName: "GetWorker",
			Handler:    _WorkerManagerService_GetWorker_Handler,
		},
		{
			MethodName: "UpdateWorkerStatus",
			Handler:    _WorkerManagerService_UpdateWorkerStatus_Handler,
		},
		{
			MethodName: "ListWorkers",
			Handler:    _WorkerManagerService_ListWorkers_Handler,
		},
		{
			MethodName: "FindAvailableWorkers",
			Handler:    _WorkerManagerService_FindAvailableWorkers_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/worker/worker.proto",
}

const (
	WorkerNodeService_ExecuteTask_FullMethodName  = "/worker.WorkerNodeService/ExecuteTask"
	WorkerNodeService_LoadModel_FullMethodName    = "/worker.WorkerNodeService/LoadModel"
	WorkerNodeService_ReportStatus_FullMethodName = "/worker.WorkerNodeService/ReportStatus"
	WorkerNodeService_SendResult_FullMethodName   = "/worker.WorkerNodeService/SendResult"
)

// WorkerNodeServiceClient is the client API for WorkerNodeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WorkerNodeServiceClient interface {
	// ExecuteTask executes a task on the worker
	ExecuteTask(ctx context.Context, in *ExecuteTaskRequest, opts ...grpc.CallOption) (*ExecuteTaskResponse, error)
	// LoadModel loads a model required for task execution
	LoadModel(ctx context.Context, in *LoadModelRequest, opts ...grpc.CallOption) (*LoadModelResponse, error)
	// ReportStatus reports the worker's current status
	ReportStatus(ctx context.Context, in *ReportStatusRequest, opts ...grpc.CallOption) (*ReportStatusResponse, error)
	// SendResult sends the result of a completed task
	SendResult(ctx context.Context, in *SendResultRequest, opts ...grpc.CallOption) (*SendResultResponse, error)
}

type workerNodeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkerNodeServiceClient(cc grpc.ClientConnInterface) WorkerNodeServiceClient {
	return &workerNodeServiceClient{cc}
}

func (c *workerNodeServiceClient) ExecuteTask(ctx context.Context, in *ExecuteTaskRequest, opts ...grpc.CallOption) (*ExecuteTaskResponse, error) {
	out := new(ExecuteTaskResponse)
	err := c.cc.Invoke(ctx, WorkerNodeService_ExecuteTask_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerNodeServiceClient) LoadModel(ctx context.Context, in *LoadModelRequest, opts ...grpc.CallOption) (*LoadModelResponse, error) {
	out := new(LoadModelResponse)
	err := c.cc.Invoke(ctx, WorkerNodeService_LoadModel_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerNodeServiceClient) ReportStatus(ctx context.Context, in *ReportStatusRequest, opts ...grpc.CallOption) (*ReportStatusResponse, error) {
	out := new(ReportStatusResponse)
	err := c.cc.Invoke(ctx, WorkerNodeService_ReportStatus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerNodeServiceClient) SendResult(ctx context.Context, in *SendResultRequest, opts ...grpc.CallOption) (*SendResultResponse, error) {
	out := new(SendResultResponse)
	err := c.cc.Invoke(ctx, WorkerNodeService_SendResult_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkerNodeServiceServer is the server API for WorkerNodeService service.
// All implementations must embed UnimplementedWorkerNodeServiceServer
// for forward compatibility
type WorkerNodeServiceServer interface {
	// ExecuteTask executes a task on the worker
	ExecuteTask(context.Context, *ExecuteTaskRequest) (*ExecuteTaskResponse, error)
	// LoadModel loads a model required for task execution
	LoadModel(context.Context, *LoadModelRequest) (*LoadModelResponse, error)
	// ReportStatus reports the worker's current status
	ReportStatus(context.Context, *ReportStatusRequest) (*ReportStatusResponse, error)
	// SendResult sends the result of a completed task
	SendResult(context.Context, *SendResultRequest) (*SendResultResponse, error)
	mustEmbedUnimplementedWorkerNodeServiceServer()
}

// UnimplementedWorkerNodeServiceServer must be embedded to have forward compatible implementations.
type UnimplementedWorkerNodeServiceServer struct {
}

func (UnimplementedWorkerNodeServiceServer) ExecuteTask(context.Context, *ExecuteTaskRequest) (*ExecuteTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteTask not implemented")
}
func (UnimplementedWorkerNodeServiceServer) LoadModel(context.Context, *LoadModelRequest) (*LoadModelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadModel not implemented")
}
func (UnimplementedWorkerNodeServiceServer) ReportStatus(context.Context, *ReportStatusRequest) (*ReportStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportStatus not implemented")
}
func (UnimplementedWorkerNodeServiceServer) SendResult(context.Context, *SendResultRequest) (*SendResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendResult not implemented")
}
func (UnimplementedWorkerNodeServiceServer) mustEmbedUnimplementedWorkerNodeServiceServer() {}

// UnsafeWorkerNodeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorkerNodeServiceServer will
// result in compilation errors.
type UnsafeWorkerNodeServiceServer interface {
	mustEmbedUnimplementedWorkerNodeServiceServer()
}

func RegisterWorkerNodeServiceServer(s grpc.ServiceRegistrar, srv WorkerNodeServiceServer) {
	s.RegisterService(&WorkerNodeService_ServiceDesc, srv)
}

func _WorkerNodeService_ExecuteTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerNodeServiceServer).ExecuteTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkerNodeService_ExecuteTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerNodeServiceServer).ExecuteTask(ctx, req.(*ExecuteTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerNodeService_LoadModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerNodeServiceServer).LoadModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkerNodeService_LoadModel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerNodeServiceServer).LoadModel(ctx, req.(*LoadModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerNodeService_ReportStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerNodeServiceServer).ReportStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkerNodeService_ReportStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerNodeServiceServer).ReportStatus(ctx, req.(*ReportStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerNodeService_SendResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerNodeServiceServer).SendResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkerNodeService_SendResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerNodeServiceServer).SendResult(ctx, req.(*SendResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// WorkerNodeService_ServiceDesc is the grpc.ServiceDesc for WorkerNodeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WorkerNodeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "worker.WorkerNodeService",
	HandlerType: (*WorkerNodeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ExecuteTask",
			Handler:    _WorkerNodeService_ExecuteTask_Handler,
		},
		{
			MethodName: "LoadModel",
			Handler:    _WorkerNodeService_LoadModel_Handler,
		},
		{
			MethodName: "ReportStatus",
			Handler:    _WorkerNodeService_ReportStatus_Handler,
		},
		{
			MethodName: "SendResult",
			Handler:    _WorkerNodeService_SendResult_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/worker/worker.proto",
}
